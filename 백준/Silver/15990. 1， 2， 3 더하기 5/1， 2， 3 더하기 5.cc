#include <iostream>

#define MOD 1'000'000'009
using namespace std;

long long dp[4][100001];


int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	//연속된 수는 사용 금지

	//N = 1
	dp[1][1] = 1; //1을 1, 2, 3의 합으로 나타내기 (1 뿐)
	dp[2][1] = 0; //안써도 되는데 명시적으로 넣음
	dp[3][1] = 0; //안써도 되는데 명시적으로 넣음

	//N = 2;
	dp[1][2] = 0; // 1,1 이라 2가 되기는 하는데 연속된 수라 불가능
	dp[2][2] = 1; //2 하나로 가능
	dp[3][2] = 0;

	//N = 3
	dp[1][3] = 1;//3이 만들어지는데 끝자리 수가 1일때의 경우의 수,
				 //3-1을 하면 2가 되는데 N이 2일때의 수를 탐색하면 된다. 
				//단 끝자리 수가 1이므로 dp[1][2]인 경우는 제외해야된다.

				//dp[1][?] 도 끝자리가 [?+?+?...1]이어서 결국엔 끝자리가 1이기 때문에 제외를 해야되는것이다.
	
	dp[2][3] = 1; //3이 만들어지는데 끝자리 수가 2일때의 경우의 수, 
				  //3-2를 하면 1이 되는데 N이 1일때의 수를 탐색하면 된다.
				  //단 끝자리 수가 2이므로 dp[2][1]인 경우는 제외해야한다.
	dp[3][3] = 1; // 3하나로 가능


	//처음 생각한 방법.. 복잡하다 게다가 정확하지도 않음
	// 
	//dp[2][1] = 1; //2를 1, 2, 3의 합으로 나타내기 (2 뿐)
	//dp[3][1] = 3; //3을 1, 2, 3의 합으로 나타내기 ({1, 2}, {2, 1}, {3})
	//dp[4] = 3; //4 ({1, 3}, {3, 1} {1, 2, 1}
	//dp[5] = 3; //{1,3,1},{2,1,2},{3,2}
	//dp[6] = 9; //{1,3,1,2},{2,1,2,1},{3,2,1} {1, 3, 2}, {3, 1, 2}, {1, 2, 1, 2}, {1, 2, 3}, {2,1,3}, {3, 2, 1}


	for (int n = 4; n <= 100'000; n++)
	{
		//i에서 1을 뺄때, 2를 뺄 때, 3을 뺄 때의 경우

			//dp[1][], dp[2][], dp[3] 확인
			//끝자리와 연속되는 경우는 제외한다.

		dp[1][n] += (dp[2][n-1] + dp[3][n-1]) % MOD;
		dp[2][n] += (dp[1][n-2] + dp[3][n-2]) % MOD;
		dp[3][n] += (dp[1][n-3] + dp[2][n-3]) % MOD;
	}

	int N, M;
	cin >> N;
	while (N--)
	{
		cin >> M;
		cout << (dp[1][M] + dp[2][M] + dp[3][M]) % MOD << '\n';
	}
}